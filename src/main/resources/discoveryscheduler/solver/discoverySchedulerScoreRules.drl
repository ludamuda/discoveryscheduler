package discoveryscheduler.solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import discoveryscheduler.domain.*;


global HardSoftScoreHolder scoreHolder;


// ############################################################################
// Hard constraints
// ############################################################################

//there is a task for each required activity: build in - exactly as many tasks are created
//task has the length of its activity: build in task.getEnd()
//TODO task starts in the morning or afternoon: build in task.start ValueRange by task.getPossibleStartList()
//task is planned between group arrival and departure: task.getPossibleStartList() selects starts from each group unique Timestamp list 

rule "outOfBounds"
	when
		Task(start != null, group.getGroupTimestampList().size()-1 < start.getTimestampIndex()+activity.getLength())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -100);
end

//task starts and ends in the same day
/* pokryto pomoci value range
rule "conflictingTaskSameDayStartInSameDayEnd"
	when
		Task(start != null, start.getDay() != getEnd().getDay())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end
*/

//group has max of two tasks per day
/* covered by one hour lunch between tasks and start at 9? NOT. */
rule "conflictingTaskGroupMoreThanTwoInSameDay"
	when
		Task($idLeft : id, start != null, $day : start.getDay(), $groupLeft : group)
		Task($idMiddle : id, id > $idLeft, start != null, start.getDay() == $day, group == $groupLeft)
		Task(id > $idMiddle, start != null, start.getDay() == $day, group == $groupLeft)
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//tasks of the same activity do not collide
/* covered by putting tasks at locations?
rule "conflictingTasksSameActivityInSameTime"
    when
        Task($leftId : id, $leftActivity : activity, $start : start, start != null, $end : getEnd())
        Task(id > $leftId, activity == $leftActivity, !((start < $start && getEnd() < $start) || (start > $end && getEnd() > $end)))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end
*/

//tasks in group do not collide
rule "conflictingTasksSameGroupInSameTime"
	when
		Task($leftId : id, $leftGroup : group, $start : start, start != null, $end : getEnd())
		Task(id > $leftId, group == $leftGroup, start != null, !((start < $start && getEnd() < $start) || (start > $end && getEnd() > $end)))
	then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//penalizes not presence of instructor if required
rule "instructorRequiredForTask"
	when 
		Task(start != null, instructor == null, isInstructorRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//penalizes presence of instructor if not required
/* NOT covered by instructor assignment rule */
rule "instructorNotRequiredForTask"
	when 
		Task(start != null, instructor != null, !isInstructorRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end


//instructors tasks cannot collide
rule "conflictInstructorsMoreTasksAtSameTime"
	when
		Task($idLeft : id, $startLeft : start, $endLeft : getEnd(), $instructorLeft : instructor, start != null, instructor != null)
		Task(id > $idLeft, instructor == $instructorLeft, !((start < $startLeft && $startLeft.getTimestampIndex() - getEnd().getTimestampIndex() >= -1 ) || (start.getTimestampIndex() - $endLeft.getTimestampIndex() >= -1   && getEnd() > $endLeft)))
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//there must be at least 1 hour for lunch
rule "conflictOneHourBetweenTasks"
	when
		Task($idLeft : id, start != null, $day : start.getDay(), $groupLeft : group, $startLeft : start, $endLeft : getEnd())
		Task(id > $idLeft, start != null, start.getDay() == $day, group == $groupLeft, (($startLeft < start && start.getTimestampIndex() - $endLeft.getTimestampIndex() <= 2) || ($startLeft > start && $startLeft.getTimestampIndex() - getEnd().getTimestampIndex() <= 2)))
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//penalizes not presence of location if required
rule "locationRequiredForTask"
	when 
		Task(start != null, location == null, isLocationRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end


//penalizes presence of location if not required
/* covered by placing tasks at its locations ?
rule "locationNotRequiredForTask"
	when 
		Task(start != null, location != null, !isLocationRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end
*/

//tasks in one location cannot collide
rule "conflictLocationsMoreTasksAtSameTime"
	when
		Task($idLeft : id, $startLeft : start, $endLeft : getEnd(), $locationLeft : location, start != null, location != null)
		Task(id > $idLeft, location == $locationLeft, !((start < $startLeft && $startLeft.getTimestampIndex() - getEnd().getTimestampIndex() >= -1 ) || (start.getTimestampIndex() - $endLeft.getTimestampIndex() >= -1   && getEnd() > $endLeft)))
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//tasks with locations must be at its locations
rule "taskAtItsLocation"
	when 
		Task(start != null, location != null, location.type != activity.name)
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end


// ############################################################################
// Soft constraints
// ############################################################################


//minimize number of instructors

//instructor should have at least 2 tasks a day for whole week
rule "instructorsPenalizeFreeTime"
	when
		accumulate(
			$day : Day(),
			$days : count($day)
		)
		$instructor : Instructor()
		and exists Task($instructor == instructor)
		$instructorTaskCount : Number(intValue <= $days.intValue()*2)accumulate(
		  	$task : Task(start != null, $instructor == instructor),
			count($task)
		)
	then
		scoreHolder.addSoftConstraintMatch(kcontext, $instructorTaskCount.intValue() - $days.intValue()*2);
end

//instructors should have same amount of tasks
rule "instructorsPenalizeDifference"
	when
		$instructorLeft : Instructor($idLeft : id)
		and exists Task($instructorLeft == instructor)
		accumulate(
		  	$task : Task(start != null, $instructorLeft == instructor),
			$instructorLeftTaskCount : count($task)
			)
		$instructorRight : Instructor(id > $idLeft)
		and exists Task($instructorRight == instructor)
		accumulate(
		  	$task : Task(start != null, $instructorRight == instructor),
			$instructorRightTaskCount : count($task)
			)
	then
		if ($instructorLeftTaskCount.intValue() < $instructorRightTaskCount.intValue())
			scoreHolder.addSoftConstraintMatch(kcontext, $instructorLeftTaskCount.intValue() - $instructorRightTaskCount.intValue());
		else
			scoreHolder.addSoftConstraintMatch(kcontext, $instructorRightTaskCount.intValue() - $instructorLeftTaskCount.intValue());
end


//instructors should have same activities in one day
// covered by instructors staying in location regardless of activity?
rule "instructorsShouldHaveSameActivityInOneDay"
	when
		Task(start != null, instructor != null, $idLeft : id, $instructorLeft : instructor, $dayLeft : getDay(), $activityLeft : activity)
		//Task($idLeft : id, $instructorLeft : instructor, instructor != null, $dayLeft : getDay(), $activityLeft : activity, start != null)
		Task(id > $idLeft, activity != $activityLeft, instructor == $instructorLeft, getDay() == $dayLeft, start !=null)
	then
	 	scoreHolder.addSoftConstraintMatch(kcontext, -1);
end

//instructor should during one day stay at one location (independent of activity)
rule "instructorsAtOneLocationInOneDay"
	when
		Task($idLeft : id, $instructorLeft : instructor, instructor != null, $dayLeft : getDay(), start != null, $locationLeft : location, location != null, $activityLeft : activity)
		Task(id > $idLeft, instructor == $instructorLeft, instructor != null,  getDay() == $dayLeft, start !=null, $locationLeft != location, location != null, activity == $activityLeft)
	then
		 scoreHolder.addSoftConstraintMatch(kcontext, -1);
end

//instructors shouldnt have 3 tasks if not neccesary
rule "instructorThreeTasksOnlyIfNeccesary"
	when
		//$instructor : Instructor()
		//$tasksInDay : Number(intValue > 2) from accumulate(

		Task($idLeft : id, start != null, $day : getDay(), $instructorLeft : instructor, instructor != null)
		Task($idMiddle : id, id > $idLeft, start != null, getDay() == $day, instructor == $instructorLeft)
		Task(id > $idMiddle, start != null, getDay() == $day, instructor == $instructorLeft)
	then
		scoreHolder.addSoftConstraintMatch(kcontext, -1);
end


//task shouldn't start before 9.00AM
rule "tasksShouldStartAfter9AM"
	when
		Task(start != null, start.getHour().getHourIndex() < 2)
	then
	 	scoreHolder.addSoftConstraintMatch(kcontext, -1);
end
