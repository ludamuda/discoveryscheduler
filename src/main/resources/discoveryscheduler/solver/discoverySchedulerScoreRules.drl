package discoveryscheduler.solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import discoveryscheduler.domain.*;


global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

//there is a task for each required activity: build in - exactly as many tasks are created
//task has the length of its activity: build in task.getEnd()
//task starts in the morning or after noon: build in task.start ValueRange by task.getPossibleStartList()
//task is planned between group arrival and departure: task.getPossibleStartList() selects starts from each group unique Timestamp list 

//task starts and ends in the same day
rule "conflictingTaskSameDayStartInSameDayEnd"
	when
		Task(start != null, start.getDay() != getEnd().getDay())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//group has max of two tasks per day
rule "conflictingTaskGroupMoreThanTwoInSameDay"
	when
		Task($idLeft : id, start != null, $day : start.getDay(), $groupLeft : group)
		Task($idMiddle : id, id > $idLeft, start != null, start.getDay() == $day, group == $groupLeft)
		Task(id > $idMiddle, start != null, start.getDay() == $day, group == $groupLeft)
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//tasks of the same activity do not collide
rule "conflictingTasksSameActivityInSameTime"
    when
        Task($leftId : id, $leftActivity : activity, $start : start, start != null, $end : getEnd())
        Task(id > $leftId, activity == $leftActivity, !((start < $start && getEnd() < $start) || (start > $end && getEnd() > $end)))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//tasks in group do not collide
rule "conflictingTasksSameGroupInSameTime"
	when
		Task($leftId : id, $leftGroup : group, $start : start, start != null, $end : getEnd())
		Task(id > $leftId, group == $leftGroup,  !((start < $start && getEnd() < $start) || (start > $end && getEnd() > $end)))
	then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//penalizes not presence of instructor if required
rule "instructorRequiredForTask"
	when 
		Task(start != null, instructor == null, isInstructorRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end

//penalizes presence of instructor if not required
rule "instructorNotRequiredForTask"
	when 
		Task(start != null, instructor != null, !isInstructorRequired())
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end


//instructors tasks cannot collide
rule "conflictInstructorsMoreTasksAtSameTime"
	when
		Task($idLeft : id, $startLeft : start, $endLeft : getEnd(), $instructorLeft : instructor, start != null, instructor != null)
		Task(id > $idLeft, instructor == $instructorLeft, !((start < $startLeft && getEnd() < $startLeft) || (start > $endLeft && getEnd() > $endLeft)))
	then
		scoreHolder.addHardConstraintMatch(kcontext, -1);
end


// ############################################################################
// Soft constraints
// ############################################################################


//minimize number of instructors
rule "instructorsMinimize"
	when
		$instructor : Instructor()
		exists Task(instructor == $instructor)
	then
		scoreHolder.addSoftConstraintMatch(kcontext, -10);
end

//instructors should have same activities in one day
rule "instructorsShouldHaveSameActivity"
	when
		Task($idLeft : id, $instructorLeft : instructor, $dayLeft : getDay(), $activityLeft : activity, start != null)
		Task(id > $idLeft, activity == $activityLeft, instructor != $instructorLeft, getDay() == $dayLeft, start !=null)
	then
	 	scoreHolder.addSoftConstraintMatch(kcontext, -1);
end

###TODO###
//task should start around 9.00
rule "tasksShouldStartLater"
	when
//		Task(start != null, start.getHour().getHourIndex() >= 2)
	then
//	 	scoreHolder.addSoftConstraintMatch(kcontext, -1);
end
